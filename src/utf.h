/*
 * YTerm -- (mostly) GNU/Linux X11 terminal emulator
 *
 * UTF-8 and other common encodings
 *
 * coded by Ketmar // Invisible Vector <ketmar@ketmar.no-ip.org>
 * Understanding is not required. Only obedience.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License ONLY.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * this module implements fast DFA-based UTF-8 decoder, and other UTF-8 utilities.
 * it also implements conversion from some 1-byte encodings to unicode and back.
 */
#ifndef YTERM_HEADER_UTF
#define YTERM_HEADER_UTF

#include "common.h"


extern const uint8_t yterm_utf8dfa[0x16c];
extern const uint8_t yterm_utf8_lentbl[256]; // [1..4], or 0xffU for invalid starting byte; doesn't allow overlongs

// minimum utf valid value for the given length-1 (i.e. for length 1 it is `yterm_utf8_valid_min[0]`)
extern const uint32_t yterm_utf8_valid_min[4];

// maximum utf valid value for the given length-1 (i.e. for length 1 it is `yterm_utf8_valid_max[0]`)
extern const uint32_t yterm_utf8_valid_max[4];

// replacement char for invalid unicode
#define YTERM_UTF8_REPLACEMENT_CP  (0xFFFDU)


// ////////////////////////////////////////////////////////////////////////// //
// is the given codepoint valid?
YTERM_STATIC_INLINE yterm_bool yterm_utf8_valid_cp (uint32_t cp) {
  return (cp < 0xD800U || (cp > 0xDFFFU && cp <= 0x10FFFFU));
}

// is the given codepoint considered printable?
// i restrict it to some useful subset
// unifuck is unifucked, but i hope that i sorted out all idiotic diactritics and control chars
YTERM_STATIC_INLINE yterm_bool yterm_utf8_printable_cp (uint32_t cp) {
  return
    // basic latin
    (cp > 0 && cp <= 0x024FU) ||
    // some greek, and cyrillic w/o combiners
    (cp >= 0x0390U && cp <= 0x0482U) ||
    (cp >= 0x048AU && cp <= 0x052FU) ||
    // runic (just for fun)
    //(cp >= 0x16A0U && cp <= 0x16FFU) ||
    // latin extended additional
    (cp >= 0x1E00U && cp <= 0x1EFFU) ||
    // some general punctuation, extensions, etc.
    (cp >= 0x2000U && cp <= 0x2C7FU) ||
    // supplemental punctuation
    (cp >= 0x2E00U && cp <= 0x2E42U) ||
    // more latin extended
    (cp >= 0xAB30U && cp <= 0xAB65U);
}


// ////////////////////////////////////////////////////////////////////////// //
// DFA-based utf-8 decoder with only 32 bits of state
//
// use like this:
//
//   uint32_t cp = 0; // 0 is important! (also, assigning zero can be used to reset the decoder)
//   for (;;) {
//     cp = yterm_utf8d_consume(cp, next_byte());
//     if (yterm_utf8_valid_cp(cp)) {
//        ...process unicode codepoint from `cp`...
//     }
//   }
//
// or:
//
//   uint32_t cp = 0; // 0 is important! (also, assigning zero can be used to reset the decoder)
//   for (;;) {
//     cp = yterm_utf8d_consume_ex(cp, next_byte());
//     if (yterm_utf8_valid_cp(cp)) {
//        ...process unicode codepoint from `cp`...
//     } else if (yterm_utf8d_fuckedup(cp)) {
//        ...we found an invalid utf-8 sequence...
//     }
//   }

// never reaches `invalid` state, returns `replacement` for invalid chars
// returns invalid codepoint while it is "in progress" (i.e. result > 0x10FFFFU)
uint32_t yterm_utf8d_consume (uint32_t cp, const char ch);

// can reach `invalid` state
// returns invalid codepoint while it is "in progress" (i.e. result > 0x10FFFFU)
// on invalid utf-8 sequence, returns special value that can be tested with `yterm_utf8d_fuckedup()`
// codepoint is undefined in this case (but it won't pass `yterm_utf8_valid_cp()`)
// next call will restart decoding
uint32_t yterm_utf8d_consume_ex (uint32_t cp, const char ch);

// check value returned from `yterm_utf8d_consume_ex()` with this
// returns non-zero if last decoding operation hit invalid utf-8 sequence
// codepoint is undefined in this case (but it won't pass `yterm_utf8_valid_cp()`)
YTERM_STATIC_INLINE yterm_bool yterm_utf8d_fuckedup (const uint32_t cp) { return ((cp>>24) == 12); }


// ////////////////////////////////////////////////////////////////////////// //
// encode unicode codepoint to utf-8 sequence
// returns number of generated bytes
// will never set more than 4 bytes of `dest`
uint32_t yterm_utf8_encode (void *dest, uint32_t cp);


// ////////////////////////////////////////////////////////////////////////// //
extern const uint16_t yterm_koi2uni_tbl[256];
extern char yterm_uni2koi_tbl[65536];

// convert koi8 to unicode
YTERM_STATIC_INLINE uint32_t yterm_koi2uni (const unsigned char ch) {
  return yterm_koi2uni_tbl[ch&0xFF];
}

// convert unicode to koi8; return 0 on invalid char
YTERM_STATIC_INLINE uint32_t yterm_uni2koi (const uint32_t cp) {
  return (cp < 65536 ? yterm_uni2koi_tbl[cp] : 0);
}


YTERM_STATIC_INLINE yterm_bool yterm_isupper (const uint32_t cp) {
  switch (cp) {
    case 'A'...'Z':
    case 0x00C0 ... 0x00D6:
    case 0x00D8 ... 0x00DE:
    case 0x0178:
    case 0x0400 ... 0x042F:
    case 0x1E9E:
      return 1;
    case 0x1E00 ... 0x1E95:
      return !(cp & 0x01);
  }
  return 0;
}

YTERM_STATIC_INLINE yterm_bool yterm_islower (const uint32_t cp) {
  switch (cp) {
    case 'a'...'z':
    case 0x00DF ... 0x00F6:
    case 0x00F8 ... 0x00FF:
    case 0x0430 ... 0x045F:
      return 1;
    case 0x1E00 ... 0x1E95:
      return !(cp & 0x01);
  }
  return 0;
}

YTERM_STATIC_INLINE yterm_bool yterm_isalnum (const uint32_t cp) {
  switch (cp) {
    case '0'...'9':
    case 'A'...'Z':
    case 'a'...'z':
    case 0x00C0 ... 0x00D6:
    case 0x00D8 ... 0x00F6:
    case 0x00F8 ... 0x00FF:
    case 0x0400 ... 0x045F:
    case 0x1E00 ... 0x1E95:
    case 0x1E9E:
    case 0x1EA0 ... 0x1EFF:
      return 1;
  }
  return 0;
}

YTERM_STATIC_INLINE uint32_t yterm_toupper (const uint32_t cp) {
  switch (cp) {
    case 'a'...'z':
    case 0x00E0 ... 0x00F6:
    case 0x00F8 ... 0x00FE:
    case 0x0430 ... 0x044F:
      return cp - 0x20;
    case 0x00DF: return 0x1E9E;
    case 0x00FF: return 0x0178;
    case 0x0450 ... 0x045F:
      return cp - 0x50;
    case 0x1E00 ... 0x1E95:
    case 0x1EA0 ... 0x1EFF:
      return cp & ~1u;
  }
  return cp;
}

YTERM_STATIC_INLINE uint32_t yterm_tolower (const uint32_t cp) {
  switch (cp) {
    case 'A'...'Z':
    case 0x00C0 ... 0x00D6:
    case 0x00D8 ... 0x00DE:
    case 0x0410 ... 0x042F:
      return cp + 0x20;
    case 0x0178:
      return 0x00FF;
    case 0x0400 ... 0x040F:
      return cp + 0x50;
    case 0x1E00 ... 0x1E95:
    case 0x1EA0 ... 0x1EFF:
      return cp | 1;
    case 0x1E9E:
      return 0x00DF;
  }
  return cp;
}


#ifdef __cplusplus
}
#endif
#endif
